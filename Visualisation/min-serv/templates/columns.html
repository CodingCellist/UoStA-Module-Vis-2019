<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js" integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <title>Column-oriented layout</title>

    <style>
        path {
            fill: none;
            stroke-opacity: 0.7;
        }

        .pre-req path {
            stroke: forestgreen;
        }

        .anti-req path {
            stroke: crimson;
        }

        .co-req path {
            stroke: cornflowerblue;
        }
    </style>
</head>
<body>
<script>
    const MY_DATA = {{ network|safe }};
    console.log(MY_DATA);

    // nest the modules by their level, i.e. the 3rd char in their name
    let nestedModules = d3.nest()
        .key(function (d) {
            return d.id[2];
        })
        .entries(MY_DATA.nodes);

    console.log(nestedModules);

    // nest the links by their type, i.e. "Pre", "Anti", and "Co"
    let nestedLinks = d3.nest()
        .key(function (d) {
            return d.type;
        })
        .entries(MY_DATA.links);

    console.log(nestedLinks);

    // attrs of svg
    const width = 960;
    const height = 960;

    const xMargin = width / 10;
    const yMargin = height / 10;

    // D3 stuff
    let svg = d3.select("body")
                .append("div")
                .attr("id", "fd-graph")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

    const nodeRadius = 5;

    // equal x-spacing (may want to change this to d3.scaleBand when doing rects)
    let xScale = d3.scalePoint(
        _.map(nestedModules, 'key'),
        [xMargin + nodeRadius, width - xMargin - nodeRadius]
    );

    // colour-coding the groups
    let schoolCodes = _.uniqBy(MY_DATA.nodes, function (n) {
        return n.id.substring(0, 2);
    });
    let colours = d3.scaleOrdinal(schoolCodes, d3.schemeCategory10);

    ///////////////////
    // NODE CREATION //
    ///////////////////

    let levelGroups = svg.selectAll("myGroups")
        .data(nestedModules)
        .enter()
        .append("g")
            .attr("transform", function (d) {
                // translate wrt. the scale defined through d3
                return "translate(" + xScale(d.key) + ", 0)";
            });

    let circles = levelGroups.selectAll("myCircles")
        .data(function (d) {
            return d.values;
        })
        .enter()
        .append("circle")
            .attr("id", function (d) {
                return d.id;
            })
            .attr("cy", function (d, i) {
                return nodeRadius + i * 2 * nodeRadius;
                // bottom-alignment:
                // return width - yMargin - (nodeRadius + i * 2 * nodeRadius);
            })
            .attr("r", nodeRadius)
            .attr("fill", function (d) {
                return colours(d.id.substring(0, 2))
            })
        .append("title")
            .text(function (d) {
                return d.id;
            });

    ///////////////////
    // LINK CREATION //
    ///////////////////

    let linkGroups = svg.selectAll("linkGroups")
        .data(nestedLinks)
        .enter()
        .append("g")
            .attr("class", function (d) {
                return d.key.toLowerCase() + "-req";
            });

    // cubic bezier links
    let horizontalLinkGenerator = d3.linkHorizontal();
    let cubicLinks = linkGroups.selectAll("myCubicLinks")
        .data(function (d) {
            return d.values;
        })
        .enter()
        .append("path")
            .attr("d", function (d) {
                // find the coordinates, with translation
                let x1 = xScale(parseInt(d.source[2])),
                    y1 = parseFloat(d3.select("#" + d.source).attr("cy")),
                    x2 = xScale(parseInt(d.target[2])),
                    y2 = parseFloat(d3.select("#" + d.target).attr("cy"));

                // store the coordinates in an object
                let coords = {
                    "source": [x1, y1],
                    "target": [x2, y2]
                };

                if (x1 === x2) {
                    // if the link is vertical do things manually
                    let diff = xScale(2) - xScale(1);
                    let cpX = x1 - diff / 2,
                        cpY = y1 > y2
                                ? y2 + (y1 - y2) / 2
                                : y1 + (y2 - y1) / 2;
                    return "M" + x1 + "," + y1
                        + " Q" + cpX + "," + cpY
                        + " " + x2 + "," + y2;
                } else {
                    return horizontalLinkGenerator(coords);
                }
            });

</script>
</body>
</html>